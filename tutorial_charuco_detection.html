<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Detection of ChArUco Corners</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">3.1.0-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li><a href="/3.0-last-rst"><span>Sphinx&#160;Documentation</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_contrib_root.html">Tutorials for contrib modules</a></li><li class="navelem"><a class="el" href="tutorial_table_of_content_aruco.html">ArUco marker detection (aruco module)</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Detection of ChArUco Corners </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ArUco markers and boards are very useful due to their fast detection and their versatility. However, one of the problems of ArUco markers is that the accuracy of their corner positions is not too high, even after applying subpixel refinement.</p>
<p>On the contrary, the corners of chessboard patterns can be refined more accurately since each corner is surrounded by two black squares. However, finding a chessboard pattern is not as versatile as finding an ArUco board: it has to be completely visible and occlusions are not permitted.</p>
<p>A ChArUco board tries to combine the benefits of these two approaches:</p>
<div class="image">
<img src="charucodefinition.png" alt="charucodefinition.png"/>
<div class="caption">
Charuco definition</div></div>
<p> The ArUco part is used to interpolate the position of the chessboard corners, so that it has the versatility of marker boards, since it allows occlusions or partial views. Moreover, since the interpolated corners belong to a chessboard, they are very accurate in terms of subpixel accuracy.</p>
<p>When high precision is necessary, such as in camera calibration, Charuco boards are a better option than standard Aruco boards.</p>
<h2>ChArUco Board Creation </h2>
<p>The aruco module provides the <code><a class="el" href="d0/d3c/classcv_1_1aruco_1_1CharucoBoard.html" title="ChArUco board Specific class for ChArUco boards. A ChArUco board is a planar board where the markers ...">cv::aruco::CharucoBoard</a></code> class that represents a Charuco Board and which inherits from the <code>Board</code> class.</p>
<p>This class, as the rest of ChArUco functionalities, are defined in:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;\#include &lt;opencv2/aruco/charuco.hpp&gt;</div></div><!-- fragment --><p>To define a <code>CharucoBoard</code>, it is necesary:</p>
<ul>
<li>Number of chessboard squares in X direction.</li>
<li>Number of chessboard squares in Y direction.</li>
<li>Length of square side.</li>
<li>Length of marker side.</li>
<li>The dictionary of the markers.</li>
<li>Ids of all the markers.</li>
</ul>
<p>As for the <code>GridBoard</code> objects, the aruco module provides a function to create <code>CharucoBoard</code>s easily. This function is the static function <code><a class="el" href="d0/d3c/classcv_1_1aruco_1_1CharucoBoard.html#ab4278128b86b6dbbc7e84d827ff175c5" title="Create a CharucoBoard object. ">cv::aruco::CharucoBoard::create()</a></code> :</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::aruco::CharucoBoard board = cv::aruco::CharucoBoard::create(5, 7, 0.04, 0.02, dictionary);</div></div><!-- fragment --><ul>
<li>The first and second parameters are the number of squares in X and Y direction respectively.</li>
<li>The third and fourth parameters are the length of the squares and the markers respectively. They can be provided in any unit, having in mind that the estimated pose for this board would be measured in the same units (usually meters are used).</li>
<li>Finally, the dictionary of the markers is provided.</li>
</ul>
<p>The ids of each of the markers are assigned by default in ascending order and starting on 0, like in <code>GridBoard::create()</code>. This can be easily customized by accessing to the ids vector through <code>board.ids</code>, like in the <code>Board</code> parent class.</p>
<p>Once we have our <code>CharucoBoard</code> object, we can create an image to print it. This can be done with the </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{CharucoBoard::draw()```}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;``` c++</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    cv::aruco::CharucoBoard board = cv::aruco::CharucoBoard::create(5, 7, 0.04, 0.02, dictionary);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    cv::Mat boardImage;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    board.draw( cv::Size(600, 500), boardImage, 10, 1 );</div></div><!-- fragment --><ul>
<li>The first parameter is the size of the output image in pixels. In this case 600x500 pixels. If this is not proportional to the board dimensions, it will be centered on the image.</li>
<li><code>boardImage</code>: the output image with the board.</li>
<li>The third parameter is the (optional) margin in pixels, so none of the markers are touching the image border. In this case the margin is 10.</li>
<li>Finally, the size of the marker border, similarly to <code><a class="el" href="d6/d6e/group__imgproc__draw.html#ga482fa7b0f578fcdd8a174904592a6250" title="Draws a marker on a predefined position in an image. ">drawMarker()</a></code> function. The default value is 1.</li>
</ul>
<p>The output image will be something like this:</p>
<div class="image">
<img src="images/charucoboard.jpg" />
</div>
<p>A full working example is included in the <code>create_board_charuco.cpp</code> inside the module samples folder.</p>
<p>Note: The samples now take input via commandline via the <a href="http://docs.opencv.org/trunk/d0/d2e/classcv_1_1CommandLineParser.html#gsc.tab=0">OpenCV Commandline Parser</a>. For this file the example parameters will look like </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&quot;_ output path_/chboard.png&quot; -w=5 -h=7 -sl=200 -ml=120 -d=10</div></div><!-- fragment --><h2>ChArUco Board Detection </h2>
<p>When you detect a ChArUco board, what you are actually detecting is each of the chessboard corners of the board.</p>
<p>Each corner on a ChArUco board has a unique identifier (id) assigned. These ids go from 0 to the total number of corners in the board.</p>
<p>So, a detected ChArUco board consists in:</p>
<ul>
<li><code>vector&lt;Point2f&gt; charucoCorners</code> : list of image positions of the detected corners.</li>
<li><code>vector &lt;int&gt; charucoIds</code> : ids for each of the detected corners in <code>charucoCorners</code>.</li>
</ul>
<p>The detection of the ChArUco corners is based on the previous detected markers. So that, first markers are detected, and then ChArUco corners are interpolated from markers.</p>
<p>The function that detect the ChArUco corners is <code><a class="el" href="d9/d6a/group__aruco.html#ga54a76b010b528af110e3aabb965cb997" title="Interpolate position of ChArUco board corners. ">cv::aruco::interpolateCornersCharuco()</a></code> . This example shows the whole process. First, markers are detected, and then the ChArUco corners are interpolated from these markers.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::Mat inputImage;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cv::Mat cameraMatrix, distCoeffs;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;// camera parameters are read from somewhere</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;readCameraParameters(cameraMatrix, distCoeffs);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;cv::aruco::Dictionary dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;cv::aruco::CharucoBoard board = cv::aruco::CharucoBoard::create(5, 7, 0.04, 0.02, dictionary);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;...</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;vector&lt; int &gt; markerIds;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;vector&lt; vector&lt;Point2f&gt; &gt; markerCorners;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;cv::aruco::detectMarkers(inputImage, board.dictionary, markerCorners, markerIds);</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;// if at least one marker detected</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;if(markerIds.size() &gt; 0) {</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::vector&lt;cv::Point2f&gt; charucoCorners;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::vector&lt;int&gt; charucoIds;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, inputImage, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div></div><!-- fragment --><p>The parameters of the <code><a class="el" href="d9/d6a/group__aruco.html#ga54a76b010b528af110e3aabb965cb997" title="Interpolate position of ChArUco board corners. ">interpolateCornersCharuco()</a></code> function are:</p><ul>
<li><code>markerCorners</code> and <code>markerIds</code>: the detected markers from <code><a class="el" href="d9/d6a/group__aruco.html#ga4ca35cee3cb3c05c209abe2581e3a6b6" title="Basic marker detection. ">detectMarkers()</a></code> function.</li>
<li><code>inputImage</code>: the original image where the markers were detected. The image is necessary to perform subpixel refinement in the ChArUco corners.</li>
<li><code>board</code>: the <code>CharucoBoard</code> object</li>
<li><code>charucoCorners</code> and <code>charucoIds</code>: the output interpolated Charuco corners</li>
<li><code>cameraMatrix</code> and <code>distCoeffs</code>: the optional camera calibration parameters</li>
<li>The function returns the number of Charuco corners interpolated.</li>
</ul>
<p>In this case, we have call <code><a class="el" href="d9/d6a/group__aruco.html#ga54a76b010b528af110e3aabb965cb997" title="Interpolate position of ChArUco board corners. ">interpolateCornersCharuco()</a></code> providing the camera calibration parameters. However these parameters are optional. A similar example without these parameters would be:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::Mat inputImage;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cv::aruco::Dictionary dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;cv::aruco::CharucoBoard board = cv::aruco::CharucoBoard::create(5, 7, 0.04, 0.02, dictionary);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;...</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;vector&lt; int &gt; markerIds;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;vector&lt; vector&lt;Point2f&gt; &gt; markerCorners;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;DetectorParameters params;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;params.doCornerRefinement = false;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;cv::aruco::detectMarkers(inputImage, board.dictionary, markerCorners, markerIds, params);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;// if at least one marker detected</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;if(markerIds.size() &gt; 0) {</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    std::vector&lt;cv::Point2f&gt; charucoCorners;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    std::vector&lt;int&gt; charucoIds;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    cv::aruco::interpolateCornersCharuco(markerCorners, markerIds, inputImage, board, charucoCorners, charucoIds);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div></div><!-- fragment --><p>If calibration parameters are provided, the ChArUco corners are interpolated by, first, estimating a rough pose from the ArUco markers and, then, reprojecting the ChArUco corners back to the image.</p>
<p>On the other hand, if calibration parameters are not provided, the ChArUco corners are interpolated by calculating the corresponding homography between the ChArUco plane and the ChArUco image projection.</p>
<p>The main problem of using homography is that the interpolation is more sensible to image distortion. Actually, the homography is only performed using the closest markers of each ChArUco corner to reduce the effect of distortion.</p>
<p>When detecting markers for ChArUco boards, and specially when using homography, it is recommended to disable the corner refinement of markers. The reason of this is that, due to the proximity of the chessboard squares, the subpixel process can produce important deviations in the corner positions and these deviations are propagated to the ChArUco corner interpolation, producing poor results.</p>
<p>Furthermore, only those corners whose two surrounding markers have be found are returned. If any of the two surrounding markers has not been detected, this usually means that there is some occlusion or the image quality is not good in that zone. In any case, it is preferable not to consider that corner, since what we want is to be sure that the interpolated ChArUco corners are very accurate.</p>
<p>After the ChArUco corners have been interpolated, a subpixel refinement is performed.</p>
<p>Once we have interpolated the ChArUco corners, we would probably want to draw them to see if their detections are correct. This can be easily done using the <code><a class="el" href="d9/d6a/group__aruco.html#ga7225eee644190f791e1583c499b7ab10" title="Draws a set of Charuco corners. ">drawDetectedCornersCharuco()</a></code> function:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::aruco::drawDetectedCornersCharuco(image, charucoCorners, charucoIds, color);</div></div><!-- fragment --><ul>
<li><code>image</code> is the image where the corners will be drawn (it will normally be the same image where the corners were detected).</li>
<li>The <code>outputImage</code> will be a clone of <code>inputImage</code> with the corners drawn.</li>
<li><code>charucoCorners</code> and <code>charucoIds</code> are the detected Charuco corners from the <code><a class="el" href="d9/d6a/group__aruco.html#ga54a76b010b528af110e3aabb965cb997" title="Interpolate position of ChArUco board corners. ">interpolateCornersCharuco()</a></code> function.</li>
<li>Finally, the last parameter is the (optional) color we want to draw the corners with, of type <code><a class="el" href="dc/d84/group__core__basic.html#ga599fe92e910c027be274233eccad7beb">cv::Scalar</a></code>.</li>
</ul>
<p>For this image:</p>
<div class="image">
<img src="choriginal.png" alt="choriginal.png"/>
<div class="caption">
Image with Charuco board</div></div>
<p> The result will be:</p>
<div class="image">
<img src="chcorners.png" alt="chcorners.png"/>
<div class="caption">
Charuco board detected</div></div>
<p> In the presence of occlusion. like in the following image, although some corners are clearly visible, not all their surrounding markers have been detected due occlusion and, thus, they are not interpolated:</p>
<div class="image">
<img src="chocclusion.png" alt="chocclusion.png"/>
<div class="caption">
Charuco detection with occlusion</div></div>
<p> Finally, this is a full example of ChArUco detection (without using calibration parameters):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::VideoCapture inputVideo;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;inputVideo.open(0);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;cv::aruco::Dictionary dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;cv::aruco::CharucoBoard board = cv::aruco::CharucoBoard::create(5, 7, 0.04, 0.02, dictionary);</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;DetectorParameters params;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;params.doCornerRefinement = false;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;while (inputVideo.grab()) {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    cv::Mat image, imageCopy;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    inputVideo.retrieve(image);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    image.copyTo(imageCopy);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    std::vector&lt;int&gt; ids;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; corners;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    cv::aruco::detectMarkers(image, dictionary, corners, ids, params);</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    // if at least one marker detected</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    if (ids.size() &gt; 0) {</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        cv::aruco::drawDetectedMarkers(imageCopy, corners, ids);</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        std::vector&lt;cv::Point2f&gt; charucoCorners;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        std::vector&lt;int&gt; charucoIds;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        cv::aruco::interpolateCornersCharuco(corners, ids, image, board, charucoCorners, charucoIds);</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        // if at least one charuco corner detected</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        if(charucoIds.size() &gt; 0)</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            cv::aruco::drawDetectedCornersCharuco(imageCopy, charucoCorners, charucoIds, cv::Scalar(255, 0, 0));</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    }</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    cv::imshow(&quot;out&quot;, imageCopy);</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    char key = (char) cv::waitKey(waitTime);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    if (key == 27)</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        break;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div></div><!-- fragment --><p>Sample video:</p>
<p> 
<iframe width="420" height="315" src="https://www.youtube.com/embed/Nj44m_N_9FY" frameborder="0" allowfullscreen></iframe>
</p>
<p>A full working example is included in the <code>detect_board_charuco.cpp</code> inside the module samples folder.</p>
<p>Note: The samples now take input via commandline via the <a href="http://docs.opencv.org/trunk/d0/d2e/classcv_1_1CommandLineParser.html#gsc.tab=0">OpenCV Commandline Parser</a>. For this file the example parameters will look like </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;-c=&quot;_path_/calib.txt&quot; -dp=&quot;_path_/detector_params.yml&quot; -w=5 -h=7 -sl=0.04 -ml=0.02 -d=10</div></div><!-- fragment --><h2>ChArUco Pose Estimation </h2>
<p>The final goal of the ChArUco boards is finding corners very accurately for a high precision calibration or pose estimation.</p>
<p>The aruco module provides a function to perform ChArUco pose estimation easily. As in the <code>GridBoard</code>, the coordinate system of the <code>CharucoBoard</code> is placed in the board plane with the Z axis pointing out, and centered in the bottom left corner of the board.</p>
<p>The function for pose estimation is <code><a class="el" href="d9/d6a/group__aruco.html#gaa6f144be4fe015e496374c1360eec555" title="Pose estimation for a ChArUco board given some of their corners. ">estimatePoseCharucoBoard()</a></code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::aruco::estimatePoseCharucoBoard(charucoCorners, charucoIds, board, cameraMatrix, distCoeffs, rvec, tvec);</div></div><!-- fragment --><ul>
<li>The <code>charucoCorners</code> and <code>charucoIds</code> parameters are the detected charuco corners from the <code><a class="el" href="d9/d6a/group__aruco.html#ga54a76b010b528af110e3aabb965cb997" title="Interpolate position of ChArUco board corners. ">interpolateCornersCharuco()</a></code> function.</li>
<li>The third parameter is the <code>CharucoBoard</code> object.</li>
<li>The <code>cameraMatrix</code> and <code>distCoeffs</code> are the camera calibration parameters which are necessary for pose estimation.</li>
<li>Finally, the <code>rvec</code> and <code>tvec</code> parameters are the output pose of the Charuco Board.</li>
<li>The function returns true if the pose was correctly estimated and false otherwise. The main reason of failing is that there are not enough corners for pose estimation or they are in the same line.</li>
</ul>
<p>The axis can be drawn using <code><a class="el" href="d9/d6a/group__aruco.html#ga16fda651a4e6a8f5747a85cbb6b400a2" title="Draw coordinate system axis from pose estimation. ">drawAxis()</a></code> to check the pose is correctly estimated. The result would be: (X:red, Y:green, Z:blue)</p>
<div class="image">
<img src="chaxis.png" alt="chaxis.png"/>
<div class="caption">
Charuco Board Axis</div></div>
<p> A full example of ChArUco detection with pose estimation:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cv::VideoCapture inputVideo;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;inputVideo.open(0);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;cv::Mat cameraMatrix, distCoeffs;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// camera parameters are read from somewhere</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;readCameraParameters(cameraMatrix, distCoeffs);</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;cv::aruco::Dictionary dictionary = cv::aruco::getPredefinedDictionary(cv::aruco::DICT_6X6_250);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;cv::aruco::CharucoBoard board = cv::aruco::CharucoBoard::create(5, 7, 0.04, 0.02, dictionary);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;while (inputVideo.grab()) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    cv::Mat image, imageCopy;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    inputVideo.retrieve(image);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    image.copyTo(imageCopy);</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    std::vector&lt;int&gt; ids;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    std::vector&lt;std::vector&lt;cv::Point2f&gt; &gt; corners;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    cv::aruco::detectMarkers(image, dictionary, corners, ids);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    // if at least one marker detected</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    if (ids.size() &gt; 0) {</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        std::vector&lt;cv::Point2f&gt; charucoCorners;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        std::vector&lt;int&gt; charucoIds;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;        cv::aruco::interpolateCornersCharuco(corners, ids, image, board, charucoCorners, charucoIds, cameraMatrix, distCoeffs);</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        // if at least one charuco corner detected</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        if(charucoIds.size() &gt; 0) {</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;            cv::aruco::drawDetectedCornersCharuco(imageCopy, charucoCorners, charucoIds, cv::Scalar(255, 0, 0));</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            cv::Vec3d rvec, tvec;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;            bool valid = cv::aruco::estimatePoseCharucoBoard(charucoCorners, charucoIds, board, cameraMatrix, distCoeffs, rvec, tvec);</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;            // if charuco pose is valid</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;            if(valid)</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;                cv::aruco::drawAxis(imageCopy, cameraMatrix, distCoeffs, rvec, tvec, 0.1);</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        }</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    }</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    cv::imshow(&quot;out&quot;, imageCopy);</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    char key = (char) cv::waitKey(waitTime);</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    if (key == 27)</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        break;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div></div><!-- fragment --><p>A full working example is included in the <code>detect_board_charuco.cpp</code> inside the module samples folder.</p>
<p>Note: The samples now take input via commandline via the <a href="http://docs.opencv.org/trunk/d0/d2e/classcv_1_1CommandLineParser.html#gsc.tab=0">OpenCV Commandline Parser</a>. For this file the example parameters will look like </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&quot;_path_/calib.txt&quot; -dp=&quot;_path_/detector_params.yml&quot; -w=5 -h=7 -sl=0.04 -ml=0.02 -d=10</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 4 2016 15:45:39 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
